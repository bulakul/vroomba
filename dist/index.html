<!DOCTYPE html>
<html>
	<head>
        <script src="lib/aframe.min.js"></script>
        <script scr="lib/aframe-extras.min.js"></script>
		<script src="lib/aframe-state-component.min.js"></script>
		<script src="lib/aframe-monster-system.js"></script>
        <script src="lib/aframe-sprite-particles-component.js"></script>
        <script src="lib/aframe-particleplayer-component.min.js"></script>


        <!-- <script src="./socket.io/socket.io.js"></script> -->
	</head>
	<body>

        <script type="text/javascript">
            var position = new THREE.Vector3();
            var prevPosition = new THREE.Vector3();
            var imageStream = null;
            var bufferSize = 90;
            var bufferPt = 0;
            var currentImgPt = 0;
            var imageArray = [];

//            var socket = io.connect('http://192.168.1.10:3000');
//
//            socket.on('position', function (data) {
//                console.log(data);
//                position = data;
//            });
//
//            socket.on('camera', function (data) {
//                //console.log(data);
//                imageArray[bufferPt] = "data:image/jpeg;base64," + JSON.parse(data).img;
//                if (bufferPt++ > bufferSize) { bufferPt = 0; }
//            });


            //Fetch data from Redis
            var url="http://localhost:8080/getredisdata";

            function worker () {
                fetch(url).then(response => response.json())
                    .then( (result) => {
                        //console.log('success:', result);
                        let j = JSON.parse(result[1]).data;
                        if (j.type == 2) {
                            imageArray[bufferPt] = "data:image/jpeg;base64," + j.img;
                            if (bufferPt++ > bufferSize) { bufferPt = 0; }
                        } else {
                            position = j.position;
                        }
                    })
                    .catch(error => console.log('error:', error));
                setTimeout("worker ()", 11);
            }

            worker ();


            AFRAME.registerComponent('vehicle', {
                schema: {
                    isVisiblePos: {type: 'boolean', default: true}
                },

                init: function () {
                    //this.player = document.querySelector('#player');

                    this.playerDebug = document.querySelector('#player-debug');
                    this.playerDebug.setAttribute('visible', this.data.isVisiblePos);
                }
            });

            //Stream images to screen
            AFRAME.registerComponent('backdrop', {
                tick: function () {
                    if (imageArray[currentImgPt]) {
                       this.el.setAttribute('src', imageArray[currentImgPt]);
                       imageArray[currentImgPt] = ""
                        if (currentImgPt++ > bufferSize) { currentImgPt = 0; }
                    }
                }
            });

            //Simulate cam data with arrow key
            AFRAME.registerComponent('xmitter', {
/*
                init: function () {

                    var offset = 0.1;

                    document.addEventListener('keydown', (e) => {

                        var currentPosition = this.el.getAttribute('position');

                        //console.log(e.code);
                        switch (e.keyCode) {
                        case 38:
                            // Up
                            position = {x: currentPosition.x, y: 0.2, z: currentPosition.z - offset};
                            break;
                        case 40:
                            // Down
                            position = {x: currentPosition.x, y: 0.2, z: currentPosition.z + offset};
                            break;
                        case 37:
                            // Left
                            position = {x: currentPosition.x - offset, y: 0.2, z: currentPosition.z};
                            break;
                        case 39:
                            // Right
                            position = {x: currentPosition.x + offset, y: 0.2, z: currentPosition.z};
                            break;
                        }

                        this.el.setAttribute('position', position);

                    });
                },
*/
/*
                tick: function () {

                    var xhttp = new XMLHttpRequest();
                    xhttp.onreadystatechange = function() {
                        if (this.readyState == 4 && this.status == 200) {
                            if (this.responseText) {
                                let result = JSON.parse(JSON.parse(this.responseText)[1]).data;
                                let img = result.img;
                                position = result.position;

                                imageArray[bufferPt] = "data:image/jpeg;base64," + img;
                                if (bufferPt++ > bufferSize) { bufferPt = 0; }
                            }
                        }
                    };
                    xhttp.open("GET", "getredisdata", true);
                    xhttp.send();

                    var setPos = position === undefined ? null : position;
                    if (setPos != null) {
                        var newPos = {x: setPos.x, y: 1.6, z: setPos.z}
                        this.el.setAttribute('position', {x: setPos.x, y: 0, z: setPos.z});
                        this.player.setAttribute('position', newPos)
                        //console.log(setPos);
                    }

                    if (this.data.isVisiblePos) {
                        //this.playerDebug.setAttribute('text', {value: JSON.stringify(newPos)});
                        this.playerDebug.setAttribute('text', {value: JSON.stringify(position)});
                    }
                }
*/

            });

            AFRAME.registerComponent('world', {

                init: function () {
                    this.xmitter = document.querySelector('#pos-transmit');
                    this.player = document.querySelector('#player');

                    this.playerDebug = document.querySelector('#player-debug');
                    this.directionVec3 = new THREE.Vector3();
                    this.playerDirectionVec3 = new THREE.Vector3();

                },

                tick: function (time, timeDelta) {

                    var newPosition = position === undefined ? null : position;

                    if (newPosition != null) {

                        this.xmitter.setAttribute('position', newPosition);

                        var currentPosition = this.el.getAttribute('position');
                        var playerCurrent = this.player.getAttribute('position');
                        this.directionVec3.copy(newPosition).sub(prevPosition);
                        this.el.setAttribute('position', {x: currentPosition.x - this.directionVec3.x, y: 0.2, z: currentPosition.z - this.directionVec3.z});
                        this.player.setAttribute('position', {x: playerCurrent.x + this.directionVec3.x, y: 0.2, z: playerCurrent.z + this.directionVec3.z});
                    }
                    prevPosition = position;
                }
            });

            AFRAME.registerComponent('cursor-selector', {
                init: function () {
                    this.el.addEventListener('click', (e) => {
                        var target = e.detail.intersection.object.el;
                        console.log("Cursor: selected " + target.id);
                        this.el.sceneEl.emit('weaponFired', {entityId: target.id});
                    });
                }
            });

            AFRAME.registerState({
                initialState: {
                    playerHealth: "50",
                    playerMaxHealth: "50",
                    message: "Awaiting new message...",
                    currentLevel: 1,
                    pushWeaponCooldownText: "PUSH CD: ",
                    pullWeaponCooldownText: "PULL CD: ",
                    numEnemiesInLevel: 10,
                    totalEnemiesDefeated: 0,
                    enemiesDefeated: 0,
                    enemiesAlive: 0,
                    enemyIds: [],
		            defeatedEnemyIds: [],
                    enemiesRayHitIds: [],
                    endLevel: 5,
                    levelMap: {
                        1: {
                            enemiesDefeated: 0,
                            totalEnemies: 5,
                        },
                        2: {
                            enemiesDefeated: 0,
                            totalEnemies: 10,
                        },
                        3: {
                            enemiesDefeated: 0,
                            totalEnemies: 15,
                        },
                        4: {
                            enemiesDefeated: 0,
                            totalEnemies: 20,
                        },
                        5: {
                            enemiesDefeated: 0,
                            totalEnemies: 25,
                        }
                    }
                },

                handlers: {
                    gameStarted: function(state, action){
                        state.message = "GAME STARTED!";
                        this.nextLevel(state, action);
                    },
                    gameWon: function(state, action){
                        state.message = "You devoured all the dust bunnies!";
                    },
                    gameLost: function(state, action){
                        state.message = "You were devoured by the dust bunnies!";
                    },
                    nextLevel: function(state, action){
                        var spawner1 = document.querySelector('#spawner1').components.spawner;
                        var spawner2 = document.querySelector('#spawner2').components.spawner;
                        let noSpawner = 2;
                        let totalEnemies = state.levelMap[state.currentLevel].totalEnemies;
                        spawner1.gameStarted();
                        spawner2.gameStarted();
                        spawner1.nextLevel(totalEnemies);
                        spawner2.nextLevel(totalEnemies);
                        state.enemiesAlive = totalEnemies * noSpawner;
                        state.enemiesDefeated = 0;
                    },
                    enemyCreated: function(state, action){
                        let enemyId = action.enemyId;
                        state.enemyIds.push(enemyId);
                    },
                    weaponFired: function(state, action) {
                        for (let id of state.enemiesRayHitIds) {
                            AFRAME.scenes[0].emit('entityHit', {entityId: id});
                        }
                        AFRAME.scenes[0].emit('entityHit', {entityId: action.entityId});

                        // Provide haptic feedback for fired weapon
                        if (navigator.getGamepads) {
                            for (let gamepad of navigator.getGamepads()) {
                                gamepad.hapticActuators[0].pulse(1, 50);
                            }
                        }
                    },
                    updateWeaponCooldown: function(state, action){
                        let effect = action.effect;
                        let timeLeft = action.timeLeft;
                        let bars = "";
                        for (let i = 0; i < timeLeft; i++){
                            bars += "|";
                        }
                        if (effect == "push"){
                            state.pushWeaponCooldownText = "PUSH CD: " + bars;
                        } else if (effect == "pull"){
                            state.pullWeaponCooldownText = "PULL CD: " + bars;
                        }
                    },
                    entityHit: function(state, action){
                        let systems = AFRAME.scenes[0].systems;
                        let entityId = action.entityId;
                        if (entityId == "pull" || entityId == "push" || entityId == "splash" || entityId == "snipe") {
                            AFRAME.scenes[0].emit('weaponChanged', {effect: entityId});
                        } else if (entityId == "start-bunny") {
                            let shootToStart = document.querySelector("#shoottostart");
                            shootToStart.parentNode.removeChild(shootToStart);

                            AFRAME.scenes[0].emit('gameStarted', {});
                        }  else if (entityId == "reset-game") {
                            let shootToReset = document.querySelector("#shoottoreset");
                            shootToReset.parentNode.removeChild(shootToReset);

                            let worldScene = document.querySelector("a-entity[world]");
                            worldScene.removeChild(worldScene.querySelector("a-entity[monsters]"));

                            let monsters = document.createElement("a-entity");
                            monsters.setAttribute('monsters', '');
                            worldScene.appendChild(monsters);

                            state.currentLevel = 1;
                            state.totalEnemiesDefeated = 0;
                            state.playerHealth = state.playerMaxHealth;
                            this.gameStarted(state, action);

                            // AFRAME.scenes[0].emit('gameStarted', {});
                        } else if (entityId && entityId.startsWith("MM_")) {
                            let enemyId = entityId;
                            let enemyEl = document.querySelector('#' + enemyId);
                            let player = document.querySelector('#player');
                            if (enemyEl) {
                                let themeSound = document.querySelector('a-entity[sound]');
                                themeSound.components.sound.playSound();
                                systems.weapon.doEffect(player, enemyEl, state.enemyIds);
                            }
                        }

                        AFRAME.scenes[0].systems.weapon.initiateCooldown();
                    },
                    enemyDefeated: function(state, action){
                        let noSpawner = 2;
                        let enemyId = action.enemyId;

                        if (state.enemyIds.includes(enemyId)){
                            state.enemyIds = state.enemyIds.filter(function(value, index, arr){
                                let deadSound = document.querySelector("#s-dead");
                                deadSound.components.sound.playSound();
                                return value != enemyId;
                            });
						}
						state.defeatedEnemyIds.push(enemyId);
                        state.enemiesAlive -= 1;
                        state.totalEnemiesDefeated += 1;
                        state.enemiesDefeated += 1;

                        if (state.currentLevel <= state.endLevel) {
                            // state.levelMap[state.currentLevel].enemiesDefeated += 1;
                            // let levelObj = state.levelMap[state.currentLevel];
                            // if (levelObj.enemiesDefeated >= levelObj.totalEnemies * noSpawner) {
                            //     state.currentLevel += 1;
                            //     AFRAME.scenes[0].emit('nextLevel');
                            // }
                            if (state.enemiesAlive <= 0) {
                                state.currentLevel += 1;
                                AFRAME.scenes[0].emit('nextLevel');
                            }
                        } else {
                            AFRAME.scenes[0].emit('gameWon');
                        }
                    },
                    playerHit: function(state, action){
                        var sceneEl = document.querySelector('a-scene');
                        let damage = action.damage;
                        let id = action.enemyId;
                        var enemyEl = document.querySelector('#' + id);
                        if (state.playerHealth > 0) {
                            state.playerHealth -= damage;
                            let sceneEl2 = document.querySelector('#glass-panel');
                            sceneEl2.emit('myHurt');
                            sceneEl.systems.monster.onHit(enemyEl,1000);

                            // Provide haptic feedback when player is taking damage
                            if (navigator.getGamepads) {
                                for (let gamepad of navigator.getGamepads()) {
                                    gamepad.hapticActuators[0].pulse(2, 500);
                                }
                            }
                        }
                        if (state.playerHealth <= 0){
                            AFRAME.scenes[0].emit('gameLost');
                            let shootToReset = document.querySelector("#shoottoreset");
                            shootToReset.setAttribute("position", "0 1.5 -1");
                            shootToReset.setAttribute("class", "collidable");
                        }
                    },
                    weaponChanged: function(state, action){
                        AFRAME.scenes[0].systems.weapon.weaponChanged(action.effect);
                    },
                    addEnemiesRayHit: function(state, action){
                        let id = action.id;
                        state.enemiesRayHitIds.push(id);
                    },
                    removeEnemiesRayHit: function(state, action){
                        let ids = action.ids;

                        for (let id of ids) {
                            state.enemiesRayHitIds.pop(id);
                        }
                    },
                    updateMessage: function(state, action){
                       state.message = action.message;
                    }
                }
            });

            AFRAME.registerComponent('vroomba-scene-setup', {
                init() {
                    // Attach objects to global scene
                    const sceneEl = document.querySelector('a-scene');

                    window.onkeyup = function(e) {
                        if (e.key == 1) {
                            //sceneEl.emit('enemyHit', {enemyId: 0, damage: 10});
                            sceneEl.emit('gameStarted');
                        } else if (e.key == 2) {
                            sceneEl.emit('enemyDefeated', {});
                        } else if (e.key == 3) {
                            sceneEl.emit('playerHit', {damage: 5});
                        } else if (e.key == 4) {
                            sceneEl.emit('weaponChanged', {effect: "pull"});
                        } else if (e.key == 5) {
                            sceneEl.emit('weaponChanged', {effect: "push"});
                        } else if (e.key == 6) {
                            sceneEl.emit('weaponChanged', {effect: "splash"});
                        } else if (e.key == 7) {
                            sceneEl.emit('weaponChanged', {effect: "snipe"});
                        } else if (e.key == 8) {
                            sceneEl.emit('weaponChanged', {effect: "normal"});
                        } else if (e.key == 9) {
                            sceneEl.emit('updateMessage', {message: "TEST"});
                        }
                    };

                }
            });

            AFRAME.registerSystem('weapon', {
                schema: {},

                init: function () {
                    this.timer = 0;
                    this.currentWeaponEffect = "normal";
                    this.shouldCheckCooldowns = false;
                    this.weaponInfo = {
                        push: {
                            effect: "push",
                            cooldown: 5,
                            damage: 5,
                            countdown: 0,
                            secondsTimer: 0
                        },
                        pull: {
                            effect: "pull",
                            cooldown: 5,
                            damage: 2,
                            countdown: 0,
                            secondsTimer: 0
                        },
                        splash: {
                            effect: "splash",
                            cooldown: 0,
                            damage: 5,
                            countdown: 0,
                            secondsTimer: 0
                        },
                        snipe: {
                            effect: "snipe",
                            cooldown: 0,
                            damage: 10,
                            countdown: 0,
                            secondsTimer: 0
                        },
                        normal: {
                            effect: "normal",
                            cooldown: 0,
                            damage: 8,
                            countdown: 0,
                            secondsTimer: 0
                        }
                    };
                    this.weaponsWithCooldowns = [this.weaponInfo.push, this.weaponInfo.pull];
                },

                tick: function () {
                    if (this.timer % 9 == 0) {
                        let continueChecking = false;
                        if (this.shouldCheckCooldowns) {
                            for (let i = 0; i < this.weaponsWithCooldowns.length; i++){
                                let weapon = this.weaponsWithCooldowns[i];
                                if (weapon.countdown > 0) {
                                    continueChecking = true;
                                    weapon.secondsTimer += 0.2;
                                    if (weapon.secondsTimer >= 1){
                                        weapon.countdown--;
                                        weapon.secondsTimer = 0;
                                        sceneEl.emit("updateWeaponCooldown", {effect: weapon.effect, timeLeft: weapon.countdown});
                                    }
                                }
                            }
                            this.shouldCheckCooldowns = continueChecking;
                        }
                    }
                    this.timer++;
                },

                isOnCooldown(weapon){
                    let weaponObj = this.weaponInfo[weapon];
                    if (weaponObj.countdown > 0){
                        return true;
                    }
                    return false
                },

                hasCooldown(effect){
                  if (effect == "push" || effect == "pull") {
                      return true;
                  }
                  return false;
                },

                initiateCooldown: function(){
                    if (this.isOnCooldown(this.currentWeaponEffect)) {
                        console.log(this.currentWeaponEffect + " gun still recharging");
                    }
                    if (this.hasCooldown(this.currentWeaponEffect) && !this.isOnCooldown(this.currentWeaponEffect)) {
                        this.weaponInfo[this.currentWeaponEffect].countdown = this.weaponInfo[this.currentWeaponEffect].cooldown;
                        sceneEl.emit("updateWeaponCooldown", {
                            effect: this.currentWeaponEffect,
                            timeLeft: this.weaponInfo[this.currentWeaponEffect].cooldown
                        });
                        this.shouldCheckCooldowns = true;
                    }
                },

                weaponChanged: function ( weaponEffect ) {
                    this.currentWeaponEffect = weaponEffect;
                },

                doEffect: function (player, target, enemyIds) {
                    if (!this.isOnCooldown(this.currentWeaponEffect)) {
                        if (this.currentWeaponEffect == "pull") {
                            this.moveMonstersToTarget(target, enemyIds);
                        } else if (this.currentWeaponEffect == "push") {
                            this.blastMonstersAwayFromTarget(player, target, enemyIds);
                        }
                        this.dealDamage(player, target, enemyIds);
                    } else {
                        console.log(this.currentWeaponEffect + " gun still recharging");
                    }
                },

                dealDamage: function(player, target, enemyIds){
                    let currentWeaponDamage = this.weaponInfo[this.currentWeaponEffect].damage;
                    if (this.currentWeaponEffect == "splash"){
                        let nearbyEnemies = this.getMonstersWithinDistanceOfTarget(target, enemyIds, 2);
                        for (let i = 0; i < nearbyEnemies.length; i++){
                            let enemy = nearbyEnemies[i];
                            this.el.sceneEl.systems.monster.onHit(enemy, currentWeaponDamage/2);
                        }
                        this.el.sceneEl.systems.monster.onHit(target, currentWeaponDamage);
                    } else if (this.currentWeaponEffect == "snipe"){
                        let nearbyEnemies = this.getMonstersWithinDistanceOfTarget(target, enemyIds, 1);
                        //console.log(nearbyEnemies);
                        if (nearbyEnemies.length == 0){
                            this.el.sceneEl.systems.monster.onHit(target, currentWeaponDamage*2);
                        } else {
                            this.el.sceneEl.systems.monster.onHit(target, currentWeaponDamage/2);
                        }
                    } else {
                        this.el.sceneEl.systems.monster.onHit(target, currentWeaponDamage);
                    }
                },

                moveMonstersToTarget: function( target, monsterIds ){
                    let targetPosition = target.getAttribute('position');
                    console.log(targetPosition);
                    for (let i = 0; i < monsterIds.length; i++){
                        var id = monsterIds[i];
                        if (id == target.id){
                            continue;
                        }
                        var el = document.querySelector('#' + id);
                        if (el != null) {
                            var newPos = {
                                x: targetPosition.x + ((Math.random() * 0.8) + -0.8),
                                y: targetPosition.y,
                                z: targetPosition.z + ((Math.random() * 0.8) + -0.8),
                            };
                            el.setAttribute('animation', 'property: position; to: ' + newPos.x + " " + newPos.y  + " " + newPos.z);
                        }
                    }
                },

                blastMonstersAwayFromTarget: function( player, target, monsterIds ){
                    let playerPosition = player.getAttribute('position');
                    let targetPosition = target.getAttribute('position');
                    for (let i = 0; i < monsterIds.length; i++){
                        var id = monsterIds[i];
                        if (id == player.id){
                            continue;
                        }
                        var el = document.querySelector('#' + id); //monster
                        var elPosition = el.getAttribute('position');
                        if (el != null) {
                            //distance from player to current iterated monster
                            let d = Math.sqrt(((playerPosition.x - elPosition.x)*(playerPosition.x - elPosition.x))
                                + ((playerPosition.z - elPosition.z)*(playerPosition.z - elPosition.z)));
                            //distance from the monster hit to the current iterated monster
                            let d2target = Math.sqrt(((targetPosition.x - elPosition.x)*(targetPosition.x - elPosition.x))
                                + ((targetPosition.z - elPosition.z)*(targetPosition.z - elPosition.z)));
                            //console.log("d: " + d.toFixed(2));
                            if (Math.abs(d2target) < 3) {
                                //**Change targetPosition to to playerPosition in the next 2 lines to make
								//the monsters move directly away from player instead of away from the monster who was hit
								//**Change the (d*#) to any value to modify the distance that the monsters are pushed away
                                let newX = targetPosition.x - (((d * 10) * (targetPosition.x - elPosition.x)) / d);
                                let newZ = targetPosition.z - (((d * 10) * (targetPosition.z - elPosition.z)) / d);
                                //this part is to move the hit-monster directly away from the player
                                if (d2target == 0){
									newX = playerPosition.x - (((d * 10) * (playerPosition.x - elPosition.x)) / d);
                                    newZ = playerPosition.z - (((d * 10) * (playerPosition.z - elPosition.z)) / d);
                                }
                                var newPos = {
                                    x: newX,
                                    y: elPosition.y,
                                    z: newZ,
                                };
                                el.setAttribute('animation', 'property: position; to: ' + newPos.x + " " + newPos.y  + " " + newPos.z + "; dur: 500");
                            }
                        }
                    }
                },

                getMonstersWithinDistanceOfTarget( target, monsterIds, distance){
                    let targetPosition = target.getAttribute('position');
                    let nearbyMonsters = [];
                    for (let i = 0; i < monsterIds.length; i++) {
                        var id = monsterIds[i];
                        if (id == target.id) {
                            continue;
                        }
                        var el = document.querySelector('#' + id);
                        if (el == null){
                            continue;
                        }
                        var elPosition = el.getAttribute('position');
                        if (el != null && targetPosition != null && elPosition != null) {
                            let d2target = Math.sqrt(((targetPosition.x - elPosition.x)*(targetPosition.x - elPosition.x)) + ((targetPosition.z - elPosition.z)*(targetPosition.z - elPosition.z)));
                            //console.log("distance " + d2target);
                            if (Math.abs(d2target) <= distance) {
                                nearbyMonsters.push(el);
                            }
                        }
                    }
                    return nearbyMonsters;
                }
            });

            AFRAME.registerComponent('weapon-trigger', {
                dependencies: ['raycaster'],

                init: function () {
                    const sceneEl = document.querySelector('a-scene');
                    // Use events to figure out what raycaster is listening so we don't have to
                    // hardcode the raycaster.
                    this.el.addEventListener('raycaster-intersection', evt => {
                        this.enemyId = evt.detail.els[0].id;
                        sceneEl.emit('addEnemiesRayHit', {id: this.enemyId});
                    });
                    this.el.addEventListener('raycaster-intersection-cleared', evt => {
                        this.enemyIds = evt.detail.clearedEls.map(el => el.id);
                        sceneEl.emit('removeEnemiesRayHit', {ids: this.enemyIds});
                    });
                    this.el.addEventListener('triggerdown', () => {
                        sceneEl.emit('weaponFired', {});

                        // Provide haptic feedback when firing weapon
                        if (navigator.getGamepads) {
                            for (let gamepad of navigator.getGamepads()) {
                                gamepad.hapticActuators[0].pulse(1, 50);
                            }
                        }
                    });
                    this.weapon = document.querySelector('#weapon-model');
                },

                tick: function () {
                    var r = this.el.object3D.rotation;
                    this.weapon.setAttribute('position', this.el.getAttribute('position'));
                    this.weapon.setAttribute('rotation', {x: 0, y: -(r.y*360/(2*Math.PI))+90, z: 0});
                }

            });

            /* global AFRAME, THREE */

            /**
            * Player for animation clips. Intended to be compatible with any model format that supports
            * skeletal or morph animations.
            */
            AFRAME.registerComponent('play-all-model-animations', {
                init: function () {
                    this.model = null;
                    this.mixer = null;

                    var model = this.el.getObject3D('mesh');
                    if (model) {
                        this.load(model);
                    } else {
                        this.el.addEventListener('model-loaded', function (e) {
                            this.load(e.detail.model);
                        }.bind(this));
                    }
                },

                load: function (model) {
                    this.model = model;
                    this.mixer = new THREE.AnimationMixer(model);
                    if (this.model.animations) {
                        for (let animation of this.model.animations) {
                            this.mixer.clipAction(animation, model).play();
                        }
                    }
                },

                tick: function (t, dt) {
                    if (this.mixer && !isNaN(dt)) {
                        this.mixer.update(dt / 1000);
                    }
                }
            });
        </script>

		<a-scene id="scene" physics vroomba-scene-setup>
        <!-- fog="color: #000; near: 5; far: 10;" -->
            <a-assets>
                <a-asset-item id="particlesJson" src="models/particles-fireworks.json"></a-asset-item>
                <img src="models/sprite.png" id="particleTex">
      
                <a-asset-item id="wall-panel-obj" src="models/Wall Panel 1.obj"></a-asset-item>
                <a-asset-item id="wooden-box-obj" src="models/wooden boxes pack.obj"></a-asset-item>
                <a-asset-item id="wooden-box-mtl" src="models/wooden boxes pack.mtl"></a-asset-item>
                <a-asset-item id="panel-obj" src="models/objPanel.obj"></a-asset-item>
                <a-asset-item id="panel-mtl" src="models/objPanel.mtl"></a-asset-item>
                <!-- <a-asset-item id="display-obj" src="models/scifi_display_OBJ.obj"></a-asset-item> -->
                <a-asset-item id="TV1-obj" src="models/Tv1.obj"></a-asset-item>
                <a-asset-item id="bunny-obj" src="models/toybunny.obj"></a-asset-item>
                <a-asset-item id="weapon-obj" src="models/railgun.obj"></a-asset-item>
                <a-asset-item id="zombieBunny" src="models/zombunny/scene.gltf"></a-asset-item>

                <a-image id="TV1-mat" src="models/Tv1.jpg"></a-image>
                <a-image id="bunny-mat" src="models/toybunny.jpg"></a-image>
                <!-- <a-image id="display-mat" src="models/scifi_display.jpg"></a-image> -->
                <a-image id="weapon-green-mat" src="models/rail-gun-green.jpg"></a-image>
                <a-image id="weapon-blue-mat" src="models/rail-gun-blue.jpg"></a-image>
                <a-image id="weapon-red-mat" src="models/rail-gun-red.jpg"></a-image>
                <a-image id="weapon-gold-mat" src="models/rail-gun-gold.jpg"></a-image>

                <a-image id="rustic-floor" src="models/rustic_floor.png"></a-image>
                <a-image id="door" src="models/space_door.jpg"></a-image>
                <a-image id="screen" src="models/screen.png"></a-image>

                <a-sound id="s-theme" src="sounds/Enemy_sounds/Peter Griffin laugh.mp3" preload="auto"></a-sound>
                <a-sound id="s-dead" src="sounds/Ambient_sounds/1-ALIEN Main Title (film version).mp3" preload="auto"></a-sound>

            </a-assets>

            <a-sky color="black" ></a-sky>

            <a-entity sound="src: #s-theme; poolSize: 10"></a-entity>
            <a-entity sound="src: #s-dead; poolSize: 10"></a-entity>


			<a-entity xmitter id="pos-transmit" geometry="primitive: cone; height: 0.4; radius-bottom: 0.2" position="0 0.2 0 "></a-entity>

            <!-- Vive controller weapon -->
            <a-entity weapon-trigger laser-controls="hand: right; model: false" line="color: red; opacity: 0.75" raycaster="objects: .collidable"></a-entity>
            <!-- <a-entity weapon-trigger laser-controls="hand: left" line="color: red; opacity: 0.75" raycaster="objects: .collidable"></a-entity> -->
            <a-entity id="weapon-model" obj-model="obj: #weapon-obj" material="src: #weapon-green-mat"></a-entity>

			<a-entity vehicle="isVisiblePos: false" position="0 0 0" rotation="0 0 0">
				<a-entity camera="active: true" position="0 1.6 0" look-controls hmdEnabled="false">
					<a-cursor position="0 0 -0.2" cursor-selector></a-cursor>
					<a-entity id="player-debug" text="value: (x, y, z); align: center; color: blue; width: 0.2; wrapCount: 20" position="0 -0.13 -0.2"></a-entity>
				</a-entity>

                <!-- Camera image -->
				<a-image backdrop src="models/vroomba_icon.png" width="38.55" height="21.68" position="0 1 -8"></a-image>

                <!-- Monitor -->
                <!-- <a-entity obj-model="obj: #display-obj" material="src: #display-mat" scale="0.15 0.17 0.27" position="-1.276 0.211 -0.234" rotation="0 -45 0"></a-entity> -->

                <!-- Vehicle structure -->
                <a-entity obj-model="obj: #wall-panel-obj;" material="src: #rustic-floor" position="-1.5 0 0.955" rotation="0 0 0"></a-entity>
                <a-entity obj-model="obj: #wall-panel-obj;" material="src: #rustic-floor" position="1.5 0 0.897" rotation="0 180 0"></a-entity>
				<!-- <a-entity id="right-wall" geometry="primitive: box; height: 3; width: 0.1" material="color: grey" rotation="0 27.5 0" position="2 1.5 0"></a-entity>
				<a-entity id="left-wall" geometry="primitive: box; height: 3; width: 0.1" material="color: grey" rotation="0 152.5 0" position="-2 1.5 0"></a-entity> -->
                <a-entity id="floor" geometry="primitive: box; height: 4; width: 0.1; depth: 5" material="src: #rustic-floor" rotation="0 0 90" position="0 0 1"></a-entity>
                <a-entity id="ceiling" geometry="primitive: box; height: 4; width: 0.1; depth: 5" material="src: #rustic-floor" rotation="0 0 90" position="0 2.837 0.99"></a-entity>
                <a-entity id="back-wall" geometry="primitive: box; height: 2.838; width: 0.1; depth: 3.5" material="src: #door" rotation="0 90 0" position="0 1.450 3.609"></a-entity>

                <a-entity id="glass-panel" geometry="primitive: box; height: 3; width: 3.5; depth: 0.01" material="color: #74adbf; opacity: 0.2; transparent: true" rotation="0 0 0" position="0 1.393 -1.234"
                animation="property:components.material.material.color; type: color; from: red; to: #74adbf; dur:666; startEvents:myHurt;">

                    <a-image src="#screen" height="2.3" width="2.3"></a-image>

                    <!-- Stat: health, level, enemies alive -->
                    <a-text id="stat-health" bind__value="value: playerHealth" width="2.3" color="#33ffcc" align="center" opacity="0.6" transparent="true" position="0.380 0.115 0"></a-text>
                    <a-text id="stat-level" bind__value="value: currentLevel" width="1.5" color="#33ffcc" align="center" opacity="0.8" transparent="true" position="0 0.965 0"></a-text>
                    <a-text id="stat-enemyalive" bind__value="value: enemiesAlive" width="1.5" color="red" align="center" opacity="0.8" transparent="true" position="0.943 0.123 0"></a-text>
                    <a-text id="stat-enemydefeated" bind__value="value: totalEnemiesDefeated" width="1.5" color="#00fdff" align="center" opacity="0.8" transparent="true" position="0.895 -0.527 0"></a-text>

                    <!-- Stat: weapon cooldown -->
                    <a-text id="stat-cool-pull" bind__value="value: pullWeaponCooldownText" width="1.5" color="#00fdff" opacity="0.8" transparent="true" position="0.5 -0.745 0"></a-text>
                    <a-text id="stat-cool-push" bind__value="value: pushWeaponCooldownText" width="1.5" color="#00fdff" opacity="0.8" transparent="true" position="0.5 -0.845 0"></a-text>

                    <a-plane width="1" height="0.5" material="color: #000000; opacity: 0.35; transparent: true" position="-0.8 0.682 0.0001">
                        <a-text id="stat-msg" bind__value="value: message" color="#00fdff" opacity="0.35" transparent="true" position="-0.43336 0.16424 0.0076" width="0.8" color="#faffef"></a-text>
                    </a-plane>

                </a-entity>


                <!-- Game Start -->
                <a-entity id="shoottostart" position="0 1.5 -1">
                    <a-entity id="start-bunny" class="collidable" id="start" gltf-model="#zombieBunny" scale="0.003 0.003 0.003"  play-all-model-animations></a-entity>
                    <a-entity text="value: SHOOT TO START; align: center; visible: true; transparent: false; color: black; height: 1; width: 3;" position="0 -0.1 0"></a-entity>
                </a-entity>


                <!-- Game End -->
                <a-entity id="shoottoreset" position="0 4.5 -1" >
                    <a-entity id="reset-game" class="collidable"  gltf-model="#zombieBunny" scale="0.003 0.003 0.003"  play-all-model-animations></a-entity>
                    <a-entity text="value: SHOOT TO RESTART; align: center; visible: true; transparent: false; color: black; height: 1; width: 3;" position="0 -0.1 0"></a-entity>
                </a-entity>


                <a-entity 
                id = "explosion"
                position="0 1 -0.5"
                trigger
                particleplayer="on:particleplayerstart; color:red; src: #particlesJson; img: #particleTex; dur: 4000; count: 50%; scale: 1; pscale: 3; interpolate: true; shader: standard; poolSize: 20"></a-entity>


                <!-- Interior decor -->
                <a-entity obj-model="obj: #wooden-box-obj; mtl: #wooden-box-mtl" scale="0.3 0.3 0.3" position="-0.04 0 2.204" rotation="0 90 0"></a-entity>
                <a-entity obj-model="obj: #panel-obj; mtl: #panel-mtl" scale="0.3 0.3 0.3" position="-1.489 0.211 2.120" rotation="0 0 0"></a-entity>
                <a-entity obj-model="obj: #TV1-obj" material="src: #TV1-mat" scale="0.11 0.11 0.11" position="1.088 0.607 1.228" rotation="0 -130 0"></a-entity>
                <a-entity obj-model="obj: #bunny-obj" material="src: #bunny-mat" scale="0.005 0.005 0.005" position="1.188 0.264 0.661" rotation="0 -115 0"></a-entity>

			</a-entity>

			<a-entity world position="0 0 0">
                <a-entity id="player" geometry="primitive: cylinder; radius: 0.2; height: 0.4" position="0 0.2 0"></a-entity>
                <a-entity spawner="monster: #monster1" id="spawner1" position="-1, 0.0001, -3"></a-entity>
                <a-entity monster="monsterType: teal; health: 30; opacity: 1" id="monster1" position="0 0.6 -3" visible="false" gltf-model="#zombieBunny" scale="0.01 0.01 0.01" animation__opacity="property: material.opacity; dir: alternate; dur: 1000; loop: true; from: 1; to: 0" play-all-model-animations></a-entity>

                <a-entity spawner="monster: #monster2" id="spawner2" position="2, 0.0001, -3"></a-entity>
                <a-entity monster="monsterType: red; health: 10; opacity: 1" id="monster2" position="0 0.45 -3" visible="false" gltf-model="#zombieBunny" scale="0.008 0.008 0.008" animation__opacity="property: material.opacity; dir: alternate; dur: 1000; loop: true; from: 1; to: 0" play-all-model-animations></a-entity>
                <a-entity monsters></a-entity>
                
            </a-entity>
            
		</a-scene>

		<script type="text/javascript">
            // The scene
            let sceneEl = document.querySelector('a-scene');
            let backdrop = document.querySelector('a-image');
            let cam = document.querySelector('a-entity[camera]');
            let vehicle = document.querySelector('a-entity[vehicle]');
            let leftWall = document.querySelector('#left-wall');
            let rightWall = document.querySelector('#right-wall');
		</script>
	</body>
</html>
