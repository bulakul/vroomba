<!DOCTYPE html>
<html>
	<head>
        <script src="lib/aframe.min.js"></script>
        <script scr="lib/aframe-extras.min.js"></script>
		<script src="lib/aframe-state-component.min.js"></script>
		<script src="lib/aframe-monster-system.js"></script>
        <script src="lib/aframe-particleplayer-component.min.js"></script>


        <!-- <script src="./socket.io/socket.io.js"></script> -->
	</head>
	<body>

        <script type="text/javascript">
            var position = new THREE.Vector3();
            var prevPosition = new THREE.Vector3();
            var imageStream = null;
            var bufferSize = 90;
            var bufferPt = 0;
            var currentImgPt = 0;
            var imageArray = [];

//            var socket = io.connect('http://192.168.1.10:3000');
//
//            socket.on('position', function (data) {
//                console.log(data);
//                position = data;
//            });
//
//            socket.on('camera', function (data) {
//                //console.log(data);
//                imageArray[bufferPt] = "data:image/jpeg;base64," + JSON.parse(data).img;
//                if (bufferPt++ > bufferSize) { bufferPt = 0; }
//            });


            //Fetch data from Redis
            var url="http://localhost:8080/getredisdata";

            function worker () {
                fetch(url).then(response => response.json())
                    .then( (result) => {
                        //console.log('success:', result);
                        let j = JSON.parse(result[1]).data;
                        if (j.type == 2) {
                            imageArray[bufferPt] = "data:image/jpeg;base64," + j.img;
                            if (bufferPt++ > bufferSize) { bufferPt = 0; }
                        } else {
                            position = j.position;
                        }
                    })
                    .catch(error => console.log('error:', error));

                setTimeout("worker ()", 11);
            }

            fetch(url).then(response => response.json())
                .then( (result) => {
                    worker ();
                })
                .catch(error => console.log('error:', error));


            AFRAME.registerComponent('vehicle', {
                schema: {
                    isVisiblePos: {type: 'boolean', default: true}
                },

                init: function () {
                    //this.player = document.querySelector('#player');

                    this.playerDebug = document.querySelector('#player-debug');
                    this.playerDebug.setAttribute('visible', this.data.isVisiblePos);
                }
            });

            //Stream images to screen
            AFRAME.registerComponent('backdrop', {
                tick: function () {
                    if (imageArray[currentImgPt]) {
                       this.el.setAttribute('src', imageArray[currentImgPt]);
                       imageArray[currentImgPt] = ""
                        if (currentImgPt++ > bufferSize) { currentImgPt = 0; }
                    }
                }
            });

            //Simulate cam data with arrow key
            AFRAME.registerComponent('xmitter', {
/*
                init: function () {

                    var offset = 0.1;

                    document.addEventListener('keydown', (e) => {

                        var currentPosition = this.el.getAttribute('position');

                        //console.log(e.code);
                        switch (e.keyCode) {
                        case 38:
                            // Up
                            position = {x: currentPosition.x, y: 0.2, z: currentPosition.z - offset};
                            break;
                        case 40:
                            // Down
                            position = {x: currentPosition.x, y: 0.2, z: currentPosition.z + offset};
                            break;
                        case 37:
                            // Left
                            position = {x: currentPosition.x - offset, y: 0.2, z: currentPosition.z};
                            break;
                        case 39:
                            // Right
                            position = {x: currentPosition.x + offset, y: 0.2, z: currentPosition.z};
                            break;
                        }

                        this.el.setAttribute('position', position);

                    });
                },
*/
/*
                tick: function () {

                    var xhttp = new XMLHttpRequest();
                    xhttp.onreadystatechange = function() {
                        if (this.readyState == 4 && this.status == 200) {
                            if (this.responseText) {
                                let result = JSON.parse(JSON.parse(this.responseText)[1]).data;
                                let img = result.img;
                                position = result.position;

                                imageArray[bufferPt] = "data:image/jpeg;base64," + img;
                                if (bufferPt++ > bufferSize) { bufferPt = 0; }
                            }
                        }
                    };
                    xhttp.open("GET", "getredisdata", true);
                    xhttp.send();

                    var setPos = position === undefined ? null : position;
                    if (setPos != null) {
                        var newPos = {x: setPos.x, y: 1.6, z: setPos.z}
                        this.el.setAttribute('position', {x: setPos.x, y: 0, z: setPos.z});
                        this.player.setAttribute('position', newPos)
                        //console.log(setPos);
                    }

                    if (this.data.isVisiblePos) {
                        //this.playerDebug.setAttribute('text', {value: JSON.stringify(newPos)});
                        this.playerDebug.setAttribute('text', {value: JSON.stringify(position)});
                    }
                }
*/

            });

            AFRAME.registerComponent('world', {

                init: function () {
                    this.xmitter = document.querySelector('#pos-transmit');
                    this.player = document.querySelector('#player');

                    this.playerDebug = document.querySelector('#player-debug');
                    this.directionVec3 = new THREE.Vector3();
                    this.playerDirectionVec3 = new THREE.Vector3();

                },

                tick: function (time, timeDelta) {

                    var newPosition = position === undefined ? null : position;

                    if (newPosition != null) {

                        this.xmitter.setAttribute('position', newPosition);

                        var currentPosition = this.el.getAttribute('position');
                        var playerCurrent = this.player.getAttribute('position');
                        this.directionVec3.copy(newPosition).sub(prevPosition);
                        this.el.setAttribute('position', {x: currentPosition.x - this.directionVec3.x, y: 0.2, z: currentPosition.z - this.directionVec3.z});
                        this.player.setAttribute('position', {x: playerCurrent.x + this.directionVec3.x, y: 0.2, z: playerCurrent.z + this.directionVec3.z});
                    }
                    prevPosition = position;
                }
            });

            AFRAME.registerComponent('cursor-selector', {
                init: function () {
                    this.el.addEventListener('click', (e) => {
                        var target = e.detail.intersection.object.el.parentEl;
                        console.log("Cursor: selected " + target.id);
                        this.el.sceneEl.emit('weaponFired', {entityId: target.id});
                    });
                }
            });

            AFRAME.registerState({
                initialState: {
                    playerHealth: "50",
                    playerMaxHealth: "50",
                    message: "Shoot to start...",
                    currentLevel: 1,
                    pushWeaponCooldownText: "PUSH CD: ",
                    pullWeaponCooldownText: "PULL CD: ",
                    numEnemiesInLevel: 10,
                    totalEnemiesDefeated: 0,
                    enemiesDefeated: 0,
                    enemiesAlive: 0,
                    enemyIds: [],
		            defeatedEnemyIds: [],
                    enemiesRayHitIds: [],
                    endLevel: 5,
                    weaponId: 0,
                    levelMap: {
                        1: {
                            enemiesDefeated: 0,
                            totalEnemies: 5,
                        },
                        2: {
                            enemiesDefeated: 0,
                            totalEnemies: 10,
                        },
                        3: {
                            enemiesDefeated: 0,
                            totalEnemies: 15,
                        },
                        4: {
                            enemiesDefeated: 0,
                            totalEnemies: 20,
                        },
                        5: {
                            enemiesDefeated: 0,
                            totalEnemies: 25,
                        }
                    }
                },

                handlers: {
                    gameStarted: function(state, action){
                        state.message = "Dust bunnies approaching...";
                        let themeSound = document.querySelector("#s-theme");
                        themeSound.components.sound.playSound();
                        this.nextLevel(state, action);
                    },
                    gameWon: function(state, action){
                        state.message = "You devoured all the dust bunnies!";
                    },
                    gameLost: function(state, action){
                        state.message = "You were devoured by the dust bunnies!";
                    },
                    nextLevel: function(state, action){
                        var spawner1 = document.querySelector('#spawner1').components.spawner;
                        var spawner2 = document.querySelector('#spawner2').components.spawner;
                        let noSpawner = 2;
                        let totalEnemies = state.levelMap[state.currentLevel].totalEnemies;
                        
                        var wave = document.querySelector('#waveAlert');
                        wave.querySelector('a-image').setAttribute('src','#wave'+state.currentLevel);
                        wave.setAttribute('position', {x: 0, y: 1, z: -1.6});
                        setTimeout(function(){
                            wave.setAttribute('position', {x: 0, y: 10, z: -1.6});
                            spawner1.gameStarted();
                            spawner2.gameStarted();
                            spawner1.nextLevel(totalEnemies);
                            spawner2.nextLevel(totalEnemies);
                            state.enemiesAlive = totalEnemies * noSpawner;
                            state.enemiesDefeated = 0;
                        }, 5000);                        
                        
                    },
                    enemyCreated: function(state, action){
                        let enemyId = action.enemyId;
                        state.enemyIds.push(enemyId);
                    },
                    weaponFired: function(state, action) {

                        for (let id of state.enemiesRayHitIds) {
                            AFRAME.scenes[0].emit('entityHit', {entityId: id});
                        }
                        AFRAME.scenes[0].emit('entityHit', {entityId: action.entityId});
                        AFRAME.scenes[0].systems.weapon.initiateCooldown();

                        // Provide haptic feedback for fired weapon
                        if (navigator.getGamepads && AFRAME.scenes[0].is('vr-mode')) {
                            for (let gamepad of navigator.getGamepads()) {
                                gamepad.hapticActuators[0].pulse(1, 50);
                            }
                        }
                    },
                    updateWeaponCooldown: function(state, action){
                        let effect = action.effect;
                        let timeLeft = action.timeLeft;
                        let bars = "";
                        for (let i = 0; i < timeLeft; i++){
                            bars += "||";
                        }
                        if (effect == "push"){
                            state.pushWeaponCooldownText = "PUSH CD: " + bars;
                        } else if (effect == "pull"){
                            state.pullWeaponCooldownText = "PULL CD: " + bars;
                        }
                    },
                    entityHit: function(state, action){
                        let systems = AFRAME.scenes[0].systems;
                        let entityId = action.entityId;
                        if (entityId == "pull" || entityId == "push" || entityId == "splash" || entityId == "snipe") {
                            AFRAME.scenes[0].emit('weaponChanged', {direction: 1});
                        } else if (entityId == "shoottostart") {
                            let shootToStart = document.querySelector("#shoottostart");
                            shootToStart.parentNode.removeChild(shootToStart);

                            AFRAME.scenes[0].emit('gameStarted', {});
                        }  else if (entityId == "shoottoreset") {
                            let shootToReset = document.querySelector("#shoottoreset");
                            shootToReset.setAttribute("position", "0 10 -1.6");

                            let worldScene = document.querySelector("a-entity[world]");
                            worldScene.removeChild(worldScene.querySelector("a-entity[monsters]"));

                            let monsters = document.createElement("a-entity");
                            monsters.setAttribute('monsters', '');
                            worldScene.appendChild(monsters);

                            state.currentLevel = 1;
                            state.totalEnemiesDefeated = 0;
                            state.playerHealth = state.playerMaxHealth;
                            this.gameStarted(state, action);

                            // AFRAME.scenes[0].emit('gameStarted', {});
                        } else if (entityId && entityId.startsWith("MM_")) {
                            let enemyId = entityId;
                            let enemyEl = document.querySelector('#' + enemyId);
                            let player = document.querySelector('#player');
                            if (enemyEl) {
                                // let hitSound = document.querySelector('#s-hit');
                                // hitSound.components.sound.playSound();
                                systems.weapon.doEffect(player, enemyEl, state.enemyIds);
                            }
                        }

                    },
                    enemyDefeated: function(state, action){
                        let enemyId = action.enemyId;

                        let deadSound = document.querySelector('#s-dead');
                        deadSound.components.sound.playSound();

      //                   if (state.enemyIds.includes(enemyId)){
      //                       state.enemyIds = state.enemyIds.filter(function(value, index, arr){
      //                           let deadSound = document.querySelector("#s-dead");
      //                           deadSound.components.sound.playSound();
      //                           return value != enemyId;
      //                       });
						// }
						// state.defeatedEnemyIds.push(enemyId);
                        state.enemyIds.pop(enemyId);
                        state.enemiesAlive -= 1;
                        state.totalEnemiesDefeated += 1;
                        state.enemiesDefeated += 1;

                        if (state.currentLevel <= state.endLevel) {
                            // state.levelMap[state.currentLevel].enemiesDefeated += 1;
                            // let levelObj = state.levelMap[state.currentLevel];
                            // if (levelObj.enemiesDefeated >= levelObj.totalEnemies * noSpawner) {
                            //     state.currentLevel += 1;
                            //     AFRAME.scenes[0].emit('nextLevel');
                            // }
                            if (state.enemiesAlive <= 0 && state.playerHealth > 0) {
                                state.currentLevel += 1;
                                AFRAME.scenes[0].emit('nextLevel');
                            }
                        } else {
                            AFRAME.scenes[0].emit('gameWon');
                        }
                    },
                    playerHit: function(state, action){
                        var sceneEl = document.querySelector('a-scene');
                        let damage = action.damage;
                        let id = action.enemyId;
                        var enemyEl = document.querySelector('#' + id);
                        if (state.playerHealth > 0) {
                            state.playerHealth -= damage;
                            let sceneEl2 = document.querySelector('#glass-panel');
                            sceneEl2.emit('myHurt');
                            sceneEl.systems.monster.onHit(enemyEl,1000);

                            // Provide haptic feedback when player is taking damage
                            if (navigator.getGamepads && AFRAME.scenes[0].is('vr-mode')) {
                                for (let gamepad of navigator.getGamepads()) {
                                    gamepad.hapticActuators[0].pulse(2, 500);
                                }
                            }
                        }
                        if (state.playerHealth <= 0){
                            var spawner1 = document.querySelector('#spawner1').components.spawner;
                            var spawner2 = document.querySelector('#spawner2').components.spawner;
                            spawner1.gameStopped();
                            spawner2.gameStopped();
                            AFRAME.scenes[0].emit('gameLost');
                            let shootToReset = document.querySelector("#shoottoreset");
                            shootToReset.setAttribute("position", "0 1 -1.6");
                            shootToReset.setAttribute("class", "collidable");
                        }
                    },
                    weaponChanged: function(state, action){
                        let weaponType = ['pull', 'push', 'splash', 'snipe', 'normal'];
                        let reloadSound = document.querySelector("#s-reload");
                        reloadSound.components.sound.playSound();
                        
                        state.weaponId += action.direction;

                        // Bound check to cycle through weapon types
                        if (state.weaponId < 0) { state.weaponId = weaponType.length-1; }
                        else if (state.weaponId > weaponType.length-1) { state.weaponId = 0; }

                        console.log(`Changed weapon to: ${weaponType[state.weaponId]}`);
                        AFRAME.scenes[0].systems.weapon.weaponChanged(weaponType[state.weaponId]);
                    },
                    addEnemiesRayHit: function(state, action){
                        let id = action.id;
                        state.enemiesRayHitIds.push(id);
                    },
                    removeEnemiesRayHit: function(state, action){
                        let ids = action.ids;

                        for (let id of ids) {
                            state.enemiesRayHitIds.pop(id);
                        }
                    },
                    updateMessage: function(state, action){
                       state.message = action.message;
                    }
                }
            });

            AFRAME.registerComponent('vroomba-scene-setup', {
                init() {
                    // Attach objects to global scene
                    const sceneEl = document.querySelector('a-scene');

                    window.onkeyup = function(e) {

                        if (e.key == 1) {
                            //sceneEl.emit('enemyHit', {enemyId: 0, damage: 10});
                            sceneEl.emit('gameStarted');
                        } else if (e.key == 2) {
                            sceneEl.emit('enemyDefeated', {});
                        } else if (e.key == 3) {
                            sceneEl.emit('playerHit', {damage: 5});
                        } else if (e.key == 4) {
                            sceneEl.emit('weaponChanged', {direction: 1});
                        } else if (e.key == 5) {
                            sceneEl.emit('weaponChanged', {direction: -1});
                        } else if (e.key == 9) {
                            sceneEl.emit('updateMessage', {message: "TEST"});
                        }
                    };

                }
            });

            AFRAME.registerSystem('weapon', {
                schema: {},

                init: function () {
                    this.timer = 0;
                    this.currentWeaponEffect = "normal";
                    //this.shouldCheckCooldowns = false;
                    this.weaponInfo = {
                        push: {
                            effect: "push",
                            cooldown: 5,
                            damage: 5,
                            countdown: 0,
                            skinId: "#weapon-red-mat"
                            // secondsTimer: 0
                        },
                        pull: {
                            effect: "pull",
                            cooldown: 5,
                            damage: 2,
                            countdown: 0,
                            skinId: "#weapon-green-mat"
                            // secondsTimer: 0
                        },
                        splash: {
                            effect: "splash",
                            cooldown: 0,
                            damage: 5,
                            countdown: 0,
                            skinId: "#weapon-blue-mat"
                            // secondsTimer: 0
                        },
                        snipe: {
                            effect: "snipe",
                            cooldown: 0,
                            damage: 10,
                            countdown: 0,
                            skinId: "#weapon-gold-mat"
                            // secondsTimer: 0
                        },
                        normal: {
                            effect: "normal",
                            cooldown: 0,
                            damage: 8,
                            countdown: 0,
                            skinId: "#weapon-green-mat"
                            // secondsTimer: 0
                        }
                    };
                    this.weaponsWithCooldowns = [this.weaponInfo.push, this.weaponInfo.pull];
                },

                tick: function () {
                    if (this.timer == 60) {

                        // let continueChecking = false;
                        // if (this.shouldCheckCooldowns) {
                        //     for (let i = 0; i < this.weaponsWithCooldowns.length; i++){
                        //         let weapon = this.weaponsWithCooldowns[i];
                        //         if (weapon.countdown > 0) {
                        //             continueChecking = true;
                        //             weapon.secondsTimer += 0.2;
                        //             if (weapon.secondsTimer >= 1){
                        //                 weapon.countdown--;
                        //                 weapon.secondsTimer = 0;
                        //                 sceneEl.emit("updateWeaponCooldown", {effect: weapon.effect, timeLeft: weapon.countdown});
                        //             }
                        //         }
                        //     }
                        //     this.shouldCheckCooldowns = continueChecking;
                        // }
                        for (let i = 0; i < this.weaponsWithCooldowns.length; i++) {
                            let weapon = this.weaponsWithCooldowns[i];
                            weapon.countdown = (weapon.countdown > 0) ? weapon.countdown - 1 : 0;
                            sceneEl.emit("updateWeaponCooldown", {effect: weapon.effect, timeLeft: weapon.countdown});
                        }

                        this.timer = 0;
                    }
                    this.timer++;
                },

                isOnCooldown(weapon){
                    let weaponObj = this.weaponInfo[weapon];
                    if (weaponObj.countdown > 0){
                        return true;
                    }
                    return false
                },

                // hasCooldown(effect){
                //   if (effect == "push" || effect == "pull") {
                //       return true;
                //   }
                //   return false;
                // },

                initiateCooldown: function(){
                    // if (this.isOnCooldown(this.currentWeaponEffect)) {
                    //     console.log(this.currentWeaponEffect + " weapon still recharging");
                    // }
                    // if (this.hasCooldown(this.currentWeaponEffect) && !this.isOnCooldown(this.currentWeaponEffect)) {
                    //     this.weaponInfo[this.currentWeaponEffect].countdown = this.weaponInfo[this.currentWeaponEffect].cooldown;
                    //     sceneEl.emit("updateWeaponCooldown", {
                    //         effect: this.currentWeaponEffect,
                    //         timeLeft: this.weaponInfo[this.currentWeaponEffect].cooldown
                    //     });
                    //     this.shouldCheckCooldowns = true;
                    // }

                    if (this.isOnCooldown(this.currentWeaponEffect)) {
                        console.log("Weapon : " + this.currentWeaponEffect + "[countdown: " + this.weaponInfo[this.currentWeaponEffect].countdown + "]");
                    } else {
                        this.weaponInfo[this.currentWeaponEffect].countdown = this.weaponInfo[this.currentWeaponEffect].cooldown;
                    }

                },

                weaponChanged: function ( weaponEffect ) {
                    let weapon = document.querySelector('#weapon-model');
                    this.currentWeaponEffect = weaponEffect;
                    weapon.setAttribute('material', 'src: '+this.weaponInfo[weaponEffect].skinId);
                },

                doEffect: function (player, target, enemyIds) {
                    if (!this.isOnCooldown(this.currentWeaponEffect)) {
                        if (this.currentWeaponEffect == "pull") {
                            this.moveMonstersToTarget(target, enemyIds);
                        } else if (this.currentWeaponEffect == "push") {
                            this.blastMonstersAwayFromTarget(player, target, enemyIds);
                        }
                        this.dealDamage(player, target, enemyIds);
                    }
                },

                dealDamage: function(player, target, enemyIds){
                    let currentWeaponDamage = this.weaponInfo[this.currentWeaponEffect].damage;
                    if (this.currentWeaponEffect == "splash"){
                        let nearbyEnemies = this.getMonstersWithinDistanceOfTarget(target, enemyIds, 2);
                        for (let i = 0; i < nearbyEnemies.length; i++){
                            let enemy = nearbyEnemies[i];
                            this.el.sceneEl.systems.monster.onHit(enemy, currentWeaponDamage/2);
                        }
                        this.el.sceneEl.systems.monster.onHit(target, currentWeaponDamage);
                    } else if (this.currentWeaponEffect == "snipe"){
                        let nearbyEnemies = this.getMonstersWithinDistanceOfTarget(target, enemyIds, 1);
                        //console.log(nearbyEnemies);
                        if (nearbyEnemies.length == 0){
                            this.el.sceneEl.systems.monster.onHit(target, currentWeaponDamage*2);
                        } else {
                            this.el.sceneEl.systems.monster.onHit(target, currentWeaponDamage/2);
                        }
                    } else {
                        this.el.sceneEl.systems.monster.onHit(target, currentWeaponDamage);
                    }
                },

                moveMonstersToTarget: function( target, monsterIds ){
                    let targetPosition = target.getAttribute('position');
                    // var carrot = document.createElement('a-entity');
                    // carrot.setAttribute('carrot', '');
                    // carrot.setAttribute('geometry', 'primitive: sphere; radius: 0.4');
                    // carrot.setAttribute('material', 'color: orange');
                    // carrot.setAttribute('position', {x: 0, y: 0.5, z: 0});
                    let bunny = target.querySelector('a-entity[gltf-model]');
                    bunny.setAttribute('gltf-model', 'models/carrot/scene.gltf');

                    //console.log(targetPosition);
                    //target.appendChild(carrot);

                    for (let i = 0; i < monsterIds.length; i++){
                        var id = monsterIds[i];
                        if (id == target.id){
                            continue;
                        }
                        var el = document.querySelector('#' + id);
                        if (el != null) {
                            var newPos = {
                                x: targetPosition.x + ((Math.random() * 0.8) + -0.8),
                                y: targetPosition.y,
                                z: targetPosition.z + ((Math.random() * 0.8) + -0.8),
                            };
                            el.setAttribute('animation', 'property: position; to: ' + newPos.x + " " + newPos.y  + " " + newPos.z);
                        }
                    }

                    setTimeout( function() {
                        //target.removeChild(carrot);
                        bunny.setAttribute('gltf-model', 'models/zombunny/scene.gltf');
                    }, 3000, target, carrot);
                },

                blastMonstersAwayFromTarget: function( player, target, monsterIds ){
                    let playerPosition = player.getAttribute('position');
                    let targetPosition = target.getAttribute('position');
                    for (let i = 0; i < monsterIds.length; i++){
                        var id = monsterIds[i];
                        if (id == player.id){
                            continue;
                        }
                        var el = document.querySelector('#' + id); //monster
                        var elPosition = el.getAttribute('position');
                        if (el != null) {
                            //distance from player to current iterated monster
                            let d = Math.sqrt(((playerPosition.x - elPosition.x)*(playerPosition.x - elPosition.x))
                                + ((playerPosition.z - elPosition.z)*(playerPosition.z - elPosition.z)));
                            //distance from the monster hit to the current iterated monster
                            let d2target = Math.sqrt(((targetPosition.x - elPosition.x)*(targetPosition.x - elPosition.x))
                                + ((targetPosition.z - elPosition.z)*(targetPosition.z - elPosition.z)));
                            //console.log("d: " + d.toFixed(2));
                            if (Math.abs(d2target) < 3) {
                                //**Change targetPosition to to playerPosition in the next 2 lines to make
								//the monsters move directly away from player instead of away from the monster who was hit
								//**Change the (d*#) to any value to modify the distance that the monsters are pushed away
                                let newX = targetPosition.x - (((d * 10) * (targetPosition.x - elPosition.x)) / d);
                                let newZ = targetPosition.z - (((d * 10) * (targetPosition.z - elPosition.z)) / d);
                                //this part is to move the hit-monster directly away from the player
                                if (d2target == 0){
									newX = playerPosition.x - (((d * 10) * (playerPosition.x - elPosition.x)) / d);
                                    newZ = playerPosition.z - (((d * 10) * (playerPosition.z - elPosition.z)) / d);
                                }
                                var newPos = {
                                    x: newX,
                                    y: elPosition.y,
                                    z: newZ
                                };
                                el.setAttribute('animation', 'property: position; to: ' + newPos.x + " " + newPos.y  + " " + newPos.z + "; dur: 500");
                            }
                        }
                    }
                },

                getMonstersWithinDistanceOfTarget( target, monsterIds, distance){
                    let targetPosition = target.getAttribute('position');
                    let nearbyMonsters = [];
                    for (let i = 0; i < monsterIds.length; i++) {
                        var id = monsterIds[i];
                        if (id == target.id) {
                            continue;
                        }
                        var el = document.querySelector('#' + id);
                        if (el == null){
                            continue;
                        }
                        var elPosition = el.getAttribute('position');
                        if (el != null && targetPosition != null && elPosition != null) {
                            let d2target = Math.sqrt(((targetPosition.x - elPosition.x)*(targetPosition.x - elPosition.x)) + ((targetPosition.z - elPosition.z)*(targetPosition.z - elPosition.z)));
                            //console.log("distance " + d2target);
                            if (Math.abs(d2target) <= distance) {
                                nearbyMonsters.push(el);
                            }
                        }
                    }
                    return nearbyMonsters;
                }
            });

            AFRAME.registerComponent('weapon-trigger', {
                dependencies: ['raycaster'],

                init: function () {
                    const sceneEl = document.querySelector('a-scene');
                    // Use events to figure out what raycaster is listening so we don't have to
                    // hardcode the raycaster.
                    this.el.addEventListener('raycaster-intersection', evt => {
                        this.enemyId = evt.detail.els[0].parentEl.id;
                        sceneEl.emit('addEnemiesRayHit', {id: this.enemyId});
                    });
                    this.el.addEventListener('raycaster-intersection-cleared', evt => {
                        this.enemyIds = evt.detail.clearedEls.map(el => el.id);
                        sceneEl.emit('removeEnemiesRayHit', {ids: this.enemyIds});
                    });
                    this.el.addEventListener('triggerdown', () => {
                        sceneEl.emit('weaponFired', {});

                        // Provide haptic feedback when firing weapon
                        if (navigator.getGamepads) {
                            for (let gamepad of navigator.getGamepads()) {
                                gamepad.hapticActuators[0].pulse(1, 50);
                            }
                        }
                    });

                    this.el.addEventListener('trackpaddown', () => {
                        sceneEl.emit('weaponChanged', {direction: 1});
                    });

                    this.weapon = document.querySelector('#weapon-model');
                },

                tick: function () {
                    var r = this.el.object3D.rotation;
                    this.weapon.setAttribute('position', this.el.getAttribute('position'));
                    this.weapon.setAttribute('rotation', {x: -(r.z*180/Math.PI), y: (r.y*180/Math.PI)+90, z: (r.x*180/Math.PI)});
                }

            });

            /* global AFRAME, THREE */

            /**
            * Player for animation clips. Intended to be compatible with any model format that supports
            * skeletal or morph animations.
            */
            AFRAME.registerComponent('play-all-model-animations', {
                init: function () {
                    this.model = null;
                    this.mixer = null;

                    var model = this.el.getObject3D('mesh');
                    if (model) {
                        this.load(model);
                    } else {
                        this.el.addEventListener('model-loaded', function (e) {
                            this.load(e.detail.model);
                        }.bind(this));
                    }
                },

                load: function (model) {
                    this.model = model;
                    this.mixer = new THREE.AnimationMixer(model);
                    if (this.model.animations) {
                        for (let animation of this.model.animations) {
                            this.mixer.clipAction(animation, model).play();
                        }
                    }
                },

                tick: function (t, dt) {
                    if (this.mixer && !isNaN(dt)) {
                        this.mixer.update(dt / 1000);
                    }
                }
            });
        </script>

		<a-scene id="scene" physics vroomba-scene-setup>
        <!-- fog="color: #000; near: 5; far: 10;" -->
            <a-assets>
                <a-asset-item id="particles-fireworks" src="models/particles-fireworks.json"></a-asset-item>
                <img src="models/sprite.png" id="particleTex">
      
                <a-asset-item id="wall-panel-obj" src="models/Wall Panel 1.obj"></a-asset-item>
                <a-asset-item id="wooden-box-obj" src="models/wooden boxes pack.obj"></a-asset-item>
                <a-asset-item id="wooden-box-mtl" src="models/wooden boxes pack.mtl"></a-asset-item>
                <a-asset-item id="panel-obj" src="models/objPanel.obj"></a-asset-item>
                <a-asset-item id="panel-mtl" src="models/objPanel.mtl"></a-asset-item>
                <!-- <a-asset-item id="display-obj" src="models/scifi_display_OBJ.obj"></a-asset-item> -->
                <a-asset-item id="TV1-obj" src="models/Tv1.obj"></a-asset-item>
                <a-asset-item id="bunny-obj" src="models/toybunny.obj"></a-asset-item>
                <a-asset-item id="weapon-obj" src="models/railgun.obj"></a-asset-item>
                <a-asset-item id="zombieBunny" src="models/zombunny/scene.gltf"></a-asset-item>
                <a-asset-item id="carrot" src="models/carrot/scene.gltf"></a-asset-item>

                <a-image id="TV1-mat" src="models/Tv1.jpg"></a-image>
                <a-image id="bunny-mat" src="models/toybunny.jpg"></a-image>
                <!-- <a-image id="display-mat" src="models/scifi_display.jpg"></a-image> -->
                <a-image id="weapon-green-mat" src="models/rail-gun-green.jpg"></a-image>
                <a-image id="weapon-blue-mat" src="models/rail-gun-blue.jpg"></a-image>
                <a-image id="weapon-red-mat" src="models/rail-gun-red.jpg"></a-image>
                <a-image id="weapon-gold-mat" src="models/rail-gun-gold.jpg"></a-image>

                <a-image id="rustic-floor" src="models/rustic_floor.png"></a-image>
                <a-image id="door" src="models/space_door.jpg"></a-image>
                <a-image id="screen" src="models/screen.png"></a-image>
                <!-- <a-image id="shootme" src="models/shootstart.png"></a-image> -->
                <a-image id="shootme7" src="models/shootme7.png"></a-image>
                <!-- <a-image id="shootme5" src="models/shootme5.png"></a-image> -->
                <a-image id="wave1" src="models/w1.png"></a-image>
                <a-image id="wave2" src="models/w2.png"></a-image>
                <a-image id="wave3" src="models/w3.png"></a-image>
                <a-image id="wave4" src="models/w4.png"></a-image>
                <a-image id="wave5" src="models/w5.png"></a-image>
                <a-image id="gameover" src="models/gameover.png"></a-image>

                <a-sound id="s-theme" src="sounds/Ambient_sounds/1-ALIEN Main Title (film version).mp3" preload="auto"></a-sound>
                <a-sound id="s-hit" src="sounds/Enemy_sounds/Peter Griffin laugh.mp3" preload="auto"></a-sound>
                <a-sound id="s-dead" src="sounds/Enemy_sounds/goatOnly.m4a" preload="auto"></a-sound>
                <a-sound id="s-reload" src="sounds/Weapon_sounds/shotgun-reload-old_school-RA_The_Sun_God-580332022.mp3" preload="auto"></a-sound>

            </a-assets>

            <a-sky color="black" ></a-sky>

            <a-entity sound="src: #s-theme; loop: true"></a-entity>
            <a-entity sound="src: #s-dead;"></a-entity>
            <a-entity sound="src: #s-reload;"></a-entity>

			<a-entity xmitter id="pos-transmit" geometry="primitive: cone; height: 0.4; radius-bottom: 0.2" material="opacity: 0; transparent: true"position="0 0.2 0 "></a-entity>

            <!-- Vive controller weapon -->
            <a-entity weapon weapon-trigger laser-controls="hand: right; model: false" line="color: red; opacity: 0.75" raycaster="objects: .collidable"></a-entity>
            <!-- <a-entity weapon weapon-trigger laser-controls="hand: left" line="color: red; opacity: 0.75" raycaster="objects: .collidable"></a-entity> -->
            <a-entity id="weapon-model" obj-model="obj: #weapon-obj" material="src: #weapon-green-mat"></a-entity>

			<a-entity vehicle="isVisiblePos: false" position="0 0 0" rotation="0 0 0">
				<a-entity camera="active: true" position="0 1.6 0" look-controls hmdEnabled="false">
					<a-cursor position="0 0 -1.5" geometry="radiusInner: 0.05; radiusOuter: 0.08" cursor-selector></a-cursor>
					<a-entity id="player-debug" text="value: (x, y, z); align: center; color: blue; width: 0.2; wrapCount: 20" position="0 -0.13 -0.2"></a-entity>
				</a-entity>

                <!-- Camera image -->
				<a-image backdrop src="" width="38.55" height="21.68" position="0 1 -8"></a-image>

                <!-- Monitor -->
                <!-- <a-entity obj-model="obj: #display-obj" material="src: #display-mat" scale="0.15 0.17 0.27" position="-1.276 0.211 -0.234" rotation="0 -45 0"></a-entity> -->

                <!-- Vehicle structure -->
                <a-entity obj-model="obj: #wall-panel-obj;" material="src: #rustic-floor" position="-1.5 0 0.955" rotation="0 0 0"></a-entity>
                <a-entity obj-model="obj: #wall-panel-obj;" material="src: #rustic-floor" position="1.5 0 0.897" rotation="0 180 0"></a-entity>
				<!-- <a-entity id="right-wall" geometry="primitive: box; height: 3; width: 0.1" material="color: grey" rotation="0 27.5 0" position="2 1.5 0"></a-entity>
				<a-entity id="left-wall" geometry="primitive: box; height: 3; width: 0.1" material="color: grey" rotation="0 152.5 0" position="-2 1.5 0"></a-entity> -->
                <a-entity id="floor" geometry="primitive: box; height: 4; width: 0.1; depth: 5" material="src: #rustic-floor" rotation="0 0 90" position="0 0 1"></a-entity>
                <a-entity id="ceiling" geometry="primitive: box; height: 4; width: 0.1; depth: 5" material="src: #rustic-floor" rotation="0 0 90" position="0 2.837 0.99"></a-entity>
                <a-entity id="back-wall" geometry="primitive: box; height: 2.838; width: 0.1; depth: 3.5" material="src: #door" rotation="0 90 0" position="0 1.450 3.609"></a-entity>

                <a-entity id="glass-panel" geometry="primitive: box; height: 3; width: 3.5; depth: 0.01" material="color: #74adbf; opacity: 0.2; transparent: true" rotation="0 0 0" position="0 1.393 -1.234"
                animation="property:components.material.material.color; type: color; from: red; to: #74adbf; dur:666; startEvents:myHurt;">

                    <a-image src="#screen" height="2.3" width="2.3"></a-image>

                    <!-- Stat: health, level, enemies alive -->
                    <a-text id="stat-health" bind__value="value: playerHealth" font="lib/Roboto-msdf.json" width="2.3" color="#33ffcc" align="center" opacity="0.6" transparent="true" position="0.380 0.115 0"></a-text>
                    <a-text id="stat-level" bind__value="value: currentLevel" font="lib/Roboto-msdf.json" width="1.5" color="#33ffcc" align="center" opacity="0.8" transparent="true" position="0 0.965 0"></a-text>
                    <a-text id="stat-enemyalive" bind__value="value: enemiesAlive" font="lib/Roboto-msdf.json" width="1.5" color="red" align="center" opacity="0.8" transparent="true" position="0.943 0.123 0"></a-text>
                    <a-text id="stat-enemydefeated" bind__value="value: totalEnemiesDefeated" font="lib/Roboto-msdf.json" width="1.5" color="#00fdff" align="center" opacity="0.8" transparent="true" position="0.895 -0.527 0"></a-text>

                    <!-- Stat: weapon cooldown -->
                    <a-text id="stat-cool-pull" bind__value="value: pullWeaponCooldownText" font="lib/Roboto-msdf.json" width="1.5" color="#00fdff" opacity="0.8" transparent="true" position="0.5 -0.745 0"></a-text>
                    <a-text id="stat-cool-push" bind__value="value: pushWeaponCooldownText" font="lib/Roboto-msdf.json" width="1.5" color="#00fdff" opacity="0.8" transparent="true" position="0.5 -0.845 0"></a-text>

                    <a-plane width="1" height="0.5" material="color: #ccffff; opacity: 0.2; transparent: true" position="-0.8 0.682 0.0001">
                        <a-text id="stat-msg" bind__value="value: message" font="lib/Roboto-msdf.json" color="#33ffcc" position="-0.433 0.13 0" width="0.9" wrap-count="20" color="#faffef"></a-text>
                    </a-plane>

                </a-entity>


                <!-- Game Start -->
                <a-entity id="shoottostart" position="0 1 -1.6">
                    <a-entity id="start-bunny" class="collidable" id="start" gltf-model="#zombieBunny" scale="0.005 0.005 0.005"  play-all-model-animations></a-entity>
                    <!-- <a-image src="#shootme" height="0.4" width="5.6" scale="0.3" position="0 0.6 -0.18"></a-image> -->
                    <a-image src="#shootme7" height="0.4" width="5.2" scale="0.3" position="0 1.1 0.374"></a-image>
                    <!-- <a-image src="#shootme5" height="0.4" width="5.8" scale="0.25" position="0 0.6 -0.18"></a-image> -->
                </a-entity>

                <!-- Wave Alert -->
                <a-entity id="waveAlert" position="0 10 -1.6">
                    <a-image src="#wave1" height="0.4" width="5.2" scale="0.3" position="0 1.1 0.374"></a-image>
                </a-entity>

                <!-- Game End -->
                <a-entity id="shoottoreset" position="0 10 -1.6" >
                    <a-entity id="reset-game" class="collidable"  gltf-model="#zombieBunny" scale="0.005 0.005 0.005"  play-all-model-animations></a-entity>
                    <a-image src="#gameover" height="0.4" width="5.2" scale="0.3" position="0 1.1 0.374"></a-image>
                </a-entity>

                <!-- particle effects -->
                <a-entity 
                    id = "explosion"
                    position="0 1 -0.5"
                    particleplayer="on:particleplayerstart; color:red; src: #particles-fireworks; img: #particleTex; dur: 4000; count: 50%; scale: 1; pscale: 3; interpolate: true; shader: standard; poolSize: 20">
                </a-entity>

                <!-- Interior decor -->
                <a-entity obj-model="obj: #wooden-box-obj; mtl: #wooden-box-mtl" scale="0.3 0.3 0.3" position="-0.04 0 2.204" rotation="0 90 0"></a-entity>
                <a-entity obj-model="obj: #panel-obj; mtl: #panel-mtl" scale="0.3 0.3 0.3" position="-1.489 0.211 2.120" rotation="0 0 0"></a-entity>
                <a-entity obj-model="obj: #TV1-obj" material="src: #TV1-mat" scale="0.11 0.11 0.11" position="1.088 0.607 1.228" rotation="0 -130 0"></a-entity>
                <a-entity obj-model="obj: #bunny-obj" material="src: #bunny-mat" scale="0.005 0.005 0.005" position="1.188 0.264 0.661" rotation="0 -115 0"></a-entity>

			</a-entity>

			<a-entity world position="0 0 0">
                <a-entity id="player" geometry="primitive: cylinder; radius: 0.2; height: 0.4" material="opacity: 0; transparent: true" position="0 0.2 0"></a-entity>
                <a-entity spawner="monster: #monster1" id="spawner1" position="-3, 0.0001, -5"></a-entity>
                <a-entity monster="monsterType: teal; health: 30; healthBarOffset: 1.5" id="monster1" position="0 0.6 -3" visible="false" sound="src: #s-hit; volume: 10">
                    <a-entity gltf-model="#zombieBunny" scale="0.01 0.01 0.01" class="collidable" animation__opacity="property: material.opacity; dir: alternate; dur: 1000; loop: true; from: 1; to: 0" material play-all-model-animations></a-entity>
                </a-entity>

                <a-entity spawner="monster: #monster2" id="spawner2" position="3, 0.0001, -5"></a-entity>
                <a-entity monster="monsterType: red; health: 10; healthBarOffset: 1.5" id="monster2" position="0 0.45 -3" visible="false" sound="src: #s-hit; volume: 10">
                    <a-entity gltf-model="#zombieBunny" scale="0.01 0.01 0.01" class="collidable" animation__opacity="property: material.opacity; dir: alternate; dur: 1000; loop: true; from: 1; to: 0" material play-all-model-animations></a-entity>
                </a-entity>

                <a-entity monsters></a-entity>
                
            </a-entity>
            
		</a-scene>

		<script type="text/javascript">
            // The scene
            let sceneEl = document.querySelector('a-scene');
            let backdrop = document.querySelector('a-image');
            let cam = document.querySelector('a-entity[camera]');
            let vehicle = document.querySelector('a-entity[vehicle]');
            let leftWall = document.querySelector('#left-wall');
            let rightWall = document.querySelector('#right-wall');
		</script>
	</body>
</html>
